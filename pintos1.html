<!DOCTYPE html>
<!--[if IE 8]> <html lang="en" class="ie8"> <![endif]-->  
<!--[if IE 9]> <html lang="en" class="ie9"> <![endif]-->  
<!--[if !IE]><!--> <html lang="en"> <!--<![endif]-->  
<head>
    <title>Pintos Document in Korean - Introduction</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">    
    <link rel="shortcut icon" href="favicon.ico">  
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">   
    <!-- Plugins CSS -->    
    <link rel="stylesheet" href="assets/plugins/font-awesome/css/font-awesome.css">
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">
    
    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
</head> 

<body class="body-green">
    <div class="page-wrapper">
        <!-- ******Header****** -->
        <header id="header" class="header">
            <div class="container">
                <div class="branding">
                    <h1 class="logo">
                        <a href="index.html">
                            <span aria-hidden="true" class="icon_documents_alt icon"></span>
                            <span class="text-bold">Pintos Document</span><span class="text-highlight"> Korean ver.</span>
                        </a>
                    </h1>
                </div><!--//branding-->
                <ol class="breadcrumb">
                    <li><a href="index.html">Home</a></li>
                    <li class="active">Introduction</li>
                </ol>
            </div><!--//container-->
        </header><!--//header-->
        <div class="doc-wrapper">
            <div class="container">
                <div id="doc-header" class="doc-header text-center">
                    <h1 class="doc-title"><i class="icon fa fa-play-circle"></i> Introduction</h1>
                    <!--<div class="meta"><i class="fa fa-clock-o"></i> Last updated: Jan 25th, 2016</div> -->
                </div><!--//doc-header-->
                <div class="doc-body">
                    <div class="doc-content">
                        <div class="content-inner">

                            <section id="intro-section" class="doc-section">
                                <h2 class="section-title">Introduction</h2>
                                <div class="section-block">
                                    <p> <b>Pintos</b>의 세계에 오신 것을 환영합니다. Pintos는 80x86 architecture의 CPU를 위한 간단한 Operating System 입니다. 이 OS는 Kernel Thread, 사용자 프로그램 (어플리케이션), 파일 시스템을 지원하기 위해 아주 간략하게 구현되어 있습니다. 이 프로젝트를 통해 여러분(그리고 여러분의 팀메이트)은 앞서 언급된 세 가지 기능을 강화시켜야 합니다. 또한, Virtual Memory를 구현하게 될 것입니다.
                                    </p>
                                    <p>
                                        이론적으로 Pintos는 보통의 IBM-호환(x86) PC에서 동작할 수 있습니다. 하지만 여러 이유로 Pintos를 각자의 PC에서 직접 돌려보는 것은 현실적으로 어렵습니다. 따라서, 우리는 system simulator 위에서 Pintos를 실행 시킬 것입니다. 이 프로그램들은 80x86 CPU와 주변 장치들을 시뮬레이트 할 수 있는 소프트웨어입니다. Pintos 프로젝트에서는 <A HREF="http://bochs.sourceforge.net">Bochs</A> 와 <A HREF="http://fabrice.bellard.free.fr/qemu/">QEMU</A> simulator를 사용합니다. 또한, <A HREF="http://www.vmware.com/">VMware Player</A>에서도 Pintos가 작동하는 것이 검증된 바 있습니다.
                                    </p>
                                    <P>
                                이 프로젝트들은 어렵습니다. 아시다시피, Pintos는 운영체제 과목과 함께하는 난이도 높은 프로젝트로 유명합니다. 하지만 이 문서를 꼼꼼히 읽고 진행한다면, 아마 많은 시행착오를 줄이고, 어렵지 않게 프로젝트를 진행해 나갈 수 있을 것입니다. 자세히 보시면 상당히 많은 팁들이 숨어 있습니다. 

                                </P>
                                <P>
                                이 장은 Pintos를 다루기 시작하는 방법을 설명합니다. 가능하다면 먼저 아래의 내용을 열심히 읽고 프로젝트를 시작하기를 권장합니다. 
                                </P>
                                </div>
                            </section><!--//doc-section-->

                            <section id="start-section" class="doc-section">
                                <h2 class="section-title">Getting Started</h2>
                                <div class="section-block">
                                   <P>

                                    프로젝트를 시작하기 위해 Pintos를 build할 수 있는 system을 준비합니다. (리눅스 머신을 권장합니다) 
                                    <A HREF="http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz">http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz</A> 의 소스코드를 받아 압축을 풀고, Pintos binary의 directory ([pintos_path]/src/utils/)를 <CODE>PATH</CODE> 환경변수에 추가해야 합니다.
                                    </P>
                                    <P>
                                </div>
                                <div id="sourcetree"  class="section-block">
                                    <h3 class="block-title">Source Tree Overview</h3>
                                    <P>
                                     이제 Pintos에 어떤 것들이 들어있는지 살펴봅시다. 아래는 <Q><TT>pintos/src</TT></Q>에서 볼 수 있는 directory들입니다.
                                    </P>

                                    <div class="table-responsive">
                                        <table class="table table-bordered">
                                            <thead>
                                                <tr>
                                                    <th>Directory Name</th>
                                                    <th>Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <th scope="row">threads/</th>
                                                    <td>Project 1부터 수정하게 될 Base kernel을 위한 source code들이 들어 있습니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">userprog/</th>
                                                    <td>Project 2에서 고치게 될 User program loader의 source code들이 들어 있습니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">vm/</th>
                                                    <td>Project 3에서 Virtual Memory를 implement할 곳입니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">filesys/</th>
                                                    <td>Basic File System의 source code들이 들어 있습니다. Project 2의 file 관련 system call을 위해 사용해야 하며, Project 4 이전에 수정할 필요는 없을 것입니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">devices/</th>
                                                    <td>I/O device (Keyboard, timer, disk, 등등) 인터페이스 관련 소스코드들이 들어있습니다. Project 1에서 timer를 고치게 될 것이며, 이외에 수정할 부분은 없을 것 입니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">lib/</th>
                                                    <td>Standard C library의 일부가 들어있습니다. 이 코드들은 pintos 커널, 사용자 프로그램과 함께 컴파일 됩니다. 이 라이브러리의 헤더파일들은 커널과 사용자 프로그램 모두에서 #include <...> 형태로 include하면 됩니다. 경우에 따라, 프로젝트를 진행하면서 이들 중 일부를 조금 고쳐야할 수도 있습니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">lib/kernel/</th>
                                                    <td>Pintos kernel만 사용하는 C library가 들어있는 디렉토리입니다. kernel code에서 사용할 수 있는 data type들 (비트맵, 더블 링크드 리스트, 해시 테이블 등)이 포함되어 있습니다. Kernel 코드에서는 이 라이브러리의 헤더 파일들을 다음과 같은 형태로 include 할 수 있습니다. #include <...></td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">lib/user/</th>
                                                    <td>Pintos의 사용자 프로그램에서만 사용되는 C Library가 들어있는 디렉토리입니다. 위와 같이, 사용자 프로그램에선 #include <...> 의 형태로 헤더 파일들을 include할 수 있습니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">tests/</th>
                                                    <td>각 프로젝트의 test들이 들어있는 디렉토리입니다. 더 많은 testing을 위해 수정하거나 추가할 수 있지만, 보통 채점은 original test들로 이루어 집니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">examples/</th>
                                                    <td>예제 사용자 프로그램들이 들어있는 디렉토리입니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">utils/</th>
                                                    <td>Pintos 커널을 simulate하기 위한 utility들이 들어있는 디렉토리 입니다.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div><!--//table-responsive-->

                                </div><!--//section-block-->
                                <div id="building"  class="section-block">
                                    <h3 class="block-title">Building Pintos</h3>
                                    <P>
                                    다음 단계로, 프로젝트 1을 위한 소스 코드를 빌드 해 봅시다.
                                    먼저, <Q><TT>threads</TT></Q> 디렉토리로 들어가서 <code> make</code> 명령어를 실행 해 봅니다. Make 스크립트가 빌드를 마치면 <Q><TT>build</TT></Q>라는 디렉토리가 생성 될 것입니다. 이 안에는 빌드가 완료된 현재 버전의 Pintos 커널이 들어있게 됩니다. 전체 빌드 과정은 보통 30초 이내 입니다. (5분 이상 걸린다면 보통 심각한 문제가 있다고 보면 됩니다.)
                                    </P>
                                    <P>
                                    Build에는 리눅스에서 흔히 사용되는 시스템 도구들을 사용합니다.
                                    </P>
                                    <P>
                                    <Q><TT>build</TT></Q> 디렉토리에서 중요한 파일들은 다음과 같습니다.
                                    </P>
                                    <div class="table-responsive">
                                        <table class="table table-bordered">
                                            <thead>
                                                <tr>
                                                    <th>File Name</th>
                                                    <th>Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <th scope="row">Makefile</th>
                                                    <td><Q><TT>pintos/src/Makefile.build</TT></Q>의 복사본입니다.  이 파일은 커널을 build하는 방법에 대한 정보를 가지고 있습니다. 자세한 내용은 <A HREF="pintos_2.html#Adding Source Files">"Adding Source Files"</A> 를 참조하시기 바랍니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">kernel.o</th>
                                                    <td>전체 커널의 Object 파일입니다. 즉, 모든 개별 커널 소스 파일들을 Link해 놓은 결과물입니다. 이 파일은 디버그 정보를 가지고 있기 때문에, GDB (see section <A HREF="pintos_10.html#SEC151">E.5 GDB</A>) 나 backtrace (Section <A HREF="pintos_10.html#SEC149">E.4 Backtraces</A> 참조)를 적용하여 디버깅을 할 수 있습니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">kernel.bin</th>
                                                    <td>Project 3에서 Virtual Memory를 implement할 곳입니다.</td>
                                                </tr>
                                                <tr>
                                                    <th scope="row">loader.bin</th>
                                                    <td>Basic File System의 source code들이 들어 있습니다. Project 2의 file 관련 system call을 위해 사용해야 하며, Project 4 이전에 수정할 필요는 없을 것입니다.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div><!--//table-responsive-->
                                    <P>


                                    <Q><TT>build</TT></Q>의 서브 디렉토리들은 컴파일러가 생성한 object 파일 (<Q><TT>.o</TT></Q>)와 
                                    dependency 파일 (<Q><TT>.d</TT></Q>)들을 포함합니다. 
                                    dependency 파일들은 <CODE>make</CODE> 스크립트에 다른 소스나 헤더파일이 변경되었을 때, 어떤 파일들이 재컴파일 되어야 하는지를 알려줍니다.
                                    </P>
                                </div><!--//section-block-->
                                <div id="running"  class="section-block">
                                    <h3 class="block-title">Running Pintos</h3>
                                    <P>
                                    우리는 Pintos를 simulator에서 쉽게 구동시킬 수 있는 프로그램인 pintos를 제공합니다. 여러분은 간단히, pintos를 <CODE>pintos <VAR>argument</VAR><small>...</small></CODE> 형태로 실행시킬 수 있습니다. 각각의 <VAR>argument</VAR>는 여러분이 수정하는 Pintos 커널로 전달 됩니다.
                                    </P>

                                    <P>
                                    먼저 새로 만들어진 <Q><TT>build</TT></Q> 디렉토리로 들어가봅시다. 그리고 <CODE>pintos run alarm-multiple</CODE> 를 입력 해 보세요. 이 명령어는 Pintos kernel에 run alarm-multiple라는 인수(argument)를 넘겨줍니다. 여기서 run 은 Pintos kernel이 테스트를 실행하라는 명령어이고, alarm-multiple은 실행시킬 테스트의 이름 입니다.
                                    </P>
                                    <P>
                                    이 명령어는 Bochs를 실행시키기 위해 필요한 <Q><TT>bochsrc.txt</TT></Q> 파일을 만듭니다. Bochs는 시뮬레이션되는 머신의 디스플레이 창을 열고, BIOS 메세지를 보여줍니다. (환경에 따라 새로운 창이 열리지 않을 수 있습니다) 그리고는 Pintos가 부팅되고 alarm-multiple 테스트 프로그램을 실행하고, 이 테스트의 실행 결과가 보여지게 됩니다. 실행이 끝나면 Bochs를 화면의 오른쪽 위에 있는 Power 버튼을 눌러 끄거나, Reset 버튼을 눌러 재실행할 수 있습니다. (환경에 따라 다를 수 있음)
                                    </P>
                                    <P>
                                    (만일 새로운 창이 뜨지 않는다면, 아마도 원격에서 로그인 한 뒤에 X forwarding을 제대로 설정하지 않은 상태일 것입니다. 그런 경우엔, X setup을 고치거나, <Q><SAMP>-v</SAMP></Q> option을 통해 X output을 비활성화 시킬 수 있습니다: <CODE>pintos -v -- run alarm-multiple</CODE>.)
                                    </P>
                                    <P>
                                    Bochs속 Pintos에서 출력된 text들은 읽기도 전에 사라졌을 수 있습니다. 하지만 Pintos는 VGA display와 first serial port로 output을 모두 전송하고 그 serial port가 Bochs의 <CODE>stdin</CODE>과 <CODE>stdout</CODE>에 연결되어 있습니다. 따라서 여러분은 <CODE>pintos run alarm-multiple &gt; logfile</CODE>과 같은 redirection을 통해 모든 출력을 logfile로 남길 수 있습니다.
                                    </P>
                                    <P>

                                    pintos 프로그램은 시뮬레이터나 가상 하드웨어를 설정할 수 있는 몇가지 옵션을 제공합니다. 옵션을 설정할 때에는 kernel로 전해질 argument들과 <Q><SAMP>--</SAMP></Q>로 구분되고, 이보다 앞에 있어야 합니다. 따라서 명령어는 <CODE>pintos <VAR>option</VAR><small>...</small> -- <VAR>argument</VAR><small>...</small></CODE>의 형태로 나타나야 합니다. Invoke 옵션은 사용할 시뮬레이트를 선택할 수 있습니다. 기본 시뮬레이터는 Bochs이나, <Q><SAMP>--qemu</SAMP></Q> 옵션을 통해 QEMU도 사용이 가능합니다. 시뮬레이터에 디버거를 붙인 상태로 구동시킬 수도 있고 (see section <A HREF="pintos_10.html#SEC151">E.5 GDB</A>), 가상머신의 메모리를 설정할 수도 있습니다.  <Q><SAMP>-v</SAMP></Q> 옵션을 통해 VGA display를 끌 수도 있고, <Q><SAMP>-t</SAMP></Q>를 통해 터미널을 VGA display로 쓸 수도 있습니다. (Bochs의  경우만 가능) 또한, <Q><SAMP>-s</SAMP></Q>를 통해 <CODE>stdin</CODE>과 <CODE>stdout</CODE>을 통한 Serial I/O를 막을 수도 있습니다.
                                    </P>
                                    <P>
                                    Pintos 커널은 run 외에 다른 명령어와 옵션을 많이 가지고 있습니다. 별로 쓸 일은 없겠지만, <Q><SAMP>-h</SAMP></Q> 옵션으로 리스트를 확인할 수 있습니다. (<CODE>pintos -h</CODE>)
                                    </P>
                                </div><!--//section-block-->
                                <div id="debugging"  class="section-block">
                                    <h3 class="block-title">Debugging versus Testing</h3>
                                    <P>
                                    코드를 디버깅 할때는 프로그램을 두번 정확히 똑같이 돌려보는게 유용할 수 있습니다. 두번째나 그 다음번에 완벽히 같은 조건으로 실행시켜 보면 문제가 정말 재현되는 것인지 확인할 수 있기 때문입니다. Pintos가 지원하는 기본 시뮬레이터인 Bochs는 재현성 모드를 지원합니다. 
                                    </P>
                                    <P>
                                    물론 시뮬레이션은 input이 완벽히 일치할 때 재현이 가능합니다. 이것은 시뮬레이션하는 컴퓨터의 전부가 같아야 한다는 뜻입니다. 예를 들어 같은 command-line argument, 같은 disk, 같은 version의 Bochs를 써야 재현이 가능합니다. (키보드 입력은 없어야 합니다, 왜냐면 여러분이 정확히 같은 타이밍에 키보드 입력을 할 수는 없기 때문입니다)
                                    </P>
                                    <P>
                                    재현성은 디버깅을 위해서는 좋지만, 대부분의 프로젝트에서 가장 중요한 thread synchronization을 테스트할 때는 문제를 야기합니다. Bochs가 재현성 모드로 설정되어 있을 때, timer interrupt는 항상 같은 시간에 발생하게 됩니다. 따라서 thread switch도 같은 시간에 발생하게 됩니다. 이것은 여러번 테스트를 수행하는 것이, synchronization 측면에서, 여러분의 코드의 신뢰성이나 정확성을 확인하는데 아무 도움이 되지 않는다는 것입니다. 
                                    </P>
                                    <P>
                                    여기서 우리는 Bochos의 &quot;jitter,&quot;라는 특성을 사용할 수 있습니다. 이것은 timer interrupt가 랜덤한 간격으로 일어나게 만듭니다. (하지만 predictable 합니다.) 여러분이 pintos에 <Q><SAMP>-j <VAR>seed</VAR></SAMP></Q> 옵션을 주면 , timer interrupt는 균일하지 않은 간격으로 일어나게 될 것입니다. 그리고 이 간격은 <Var>seed</Var>에 의존적이기 때문에, 이 변수를 바꾸지 않는 한 재현성은 유지 될 것입니다. 따라서, 여러분은 코드의 신뢰성을 높이기 위해 여러 seed 값으로 테스트를 실행 해야 합니다. 
                                    </P>
                                    <P>
                                    다른 한편, Bochs가 재현성 모드로 동작할때 타이밍은 현실적이지 않습니다. (1의 delay가 실제로 그보다 훨씬 짧거나, 길 수 있습니다) 이를 막기 위해 다른 옵션을 사용할 수 있습니다. <Q><SAMP>-r</SAMP></Q> 옵션을 사용하면 Bochs가 현실적인 타이밍을 사용하도록 합니다. 다만, 이 모드에서는 재현성이 보장되지 않으며, <Q><SAMP>-j</SAMP></Q> 옵션을 사용할 수 없습니다. 
                                    </P>
                                    <P>
                                    Bochs 대신 QEMU 시뮬레이터를 사용할 수도 있습니다. (pintos를 실행할 때 <Q><SAMP>--qemu</SAMP></Q> 옵션을 사용하면 됩니다)  QEMU는 Bochs보다 훨씬 빠릅니다. 다만, 이 시뮬레이터는 실시간(*현실적인) 시뮬레이션만 가능하며, 재현성 모드를 지원하지 않습니다.
                                    </P>
                                </div><!--//section-block-->
                            </section><!--//doc-section-->

                            <section id="grading-section" class="doc-section">
                                <h2 class="section-title">Grading</h2>
								<p>  보통 Pintos Project는 test 점수와 디자인 품질(Design document + implementation)로 평가합니다. 각각의 비중은 교과목 담당 교수님에 따라 다를 것입니다. (Stanford의 경우 50:50이라고 합니다.)
                                </p>
                                <div id="testing"  class="section-block">
                                    <h3 class="block-title">Testing</h3>
                                    <p> 여러분의 test 점수는 각각의 test의 통과 여부에 따라 결정됩니다. 각각의 프로젝트는 몇개씩의 test를 가지고 있습니다. 결과물을 test하기 위해, 프로젝트의 디렉토리에서 <CODE>make check</CODE>를 실행하세요. 이 명령어는 프로젝트를 빌드하고 각각의 테스트를 수행한 뒤, 어떤 test가 통과되거나 실패했는지 출력하게 합니다. 어떤 테스트가 실패하는 경우, <CODE>make check</CODE>는 간략한 실패 사유 또한 보여줄 것입니다. 모든 테스트가 수행된 후에는 결과의 요약이 보여집니다.
                                    </p>
									<P>
                                        Project 1의 경우는 Bochs에서 테스트들이 더 빠르게 돌아 갈 것입니다. 나머지의 경우는 QEMU에서 훨씬 빠를 것입니다. <CODE>make check</CODE>는 기본적으로 빠른 시뮬레이터를 사용합니다. 하지만 여러분은 <Q><SAMP>SIMULATOR=--bochs</SAMP></Q>나 <Q><SAMP>SIMULATOR=--qemu</SAMP></Q>의 옵션을 사용하여 시뮬레이터를 선택할 수 있습니다.
											</P>
											<P>

                                            또한 여러분은 한번에 한가지 테스트만을 실행해 볼 수도 있습니다. Test <VAR>t</VAR>는 <Q><TT><VAR>t</VAR>.output</TT></Q>에 출력물을 기록합니다. 그러면 어떤 스크립트가 이 output을 읽어 pass인지 fail인지 판단하게 되고, 판단 결과를 <Q><TT><VAR>t</VAR>.result</TT></Q>에 쓰게 됩니다. 한가지 테스트를 실행하기 위해서는 해당되는 result file을 <Q><TT>build</TT></Q> 디렉토리에서 <CODE>make</CODE> 하면 됩니다. 예를 들어 <CODE>make tests/threads/alarm-multiple.result</CODE> 명령어를 실행하면 alarm-multiple 테스트를 실행하게 됩니다. 만약 <CODE>make</CODE>에서 "test result is up-to-date"라는 출력을 하지만 다시 돌려보고 싶다면, <Code>make clean</Code>을 하거나, <Q><TT>.output</TT></Q>파일을 지우고 다시 실행하면 됩니다.
											</P>
											<P>

											By default, each test provides feedback only at completion, not during
											its run.  If you prefer, you can observe the progress of each test by
											specifying <Q><SAMP>VERBOSE=1</SAMP></Q> on the <CODE>make</CODE> command line, as in
											<CODE>make check VERBOSE=1</CODE>.  You can also provide arbitrary options to the
											<CODE>pintos</CODE> run by the tests with <Q><SAMP>PINTOSOPTS='<small>...</small>'</SAMP></Q>,
											e.g. <CODE>make check PINTOSOPTS='-j 1'</CODE> to select a jitter value of 1
											(see section <A HREF="pintos_1.html#SEC6">1.1.4 Debugging versus Testing</A>).
											</P>
											<P>

											All of the tests and related files are in <Q><TT>pintos/src/tests</TT></Q>.
											Before we test your submission, we will replace the contents of that
											directory by a pristine, unmodified copy, to ensure that the correct
											tests are used.  Thus, you can modify some of the tests if that helps in
											debugging, but we will run the originals.
											</P>
											<P>

											All software has bugs, so some of our tests may be flawed.  If you think
											a test failure is a bug in the test, not a bug in your code,
											please point it out.  We will look at it and fix it if necessary.
											</P>
											<P>

											Please don't try to take advantage of our generosity in giving out our
											test suite.  Your code has to work properly in the general case, not
											just for the test cases we supply.  For example, it would be unacceptable
											to explicitly base the kernel's behavior on the name of the running
											test case.  Such attempts to side-step the test cases will receive no
											credit.  If you think your solution may be in a gray area here, please
											ask us about it.
											</P>

                                </div><!--//section-block-->
                                <div id="design"  class="section-block">
                                    <h3 class="block-title">Design</h3>
									<P>

									We will judge your design based on the design document and the source
									code that you submit.  We will read your entire design document and much
									of your source code.  
									</P>
									<P>

									Don't forget that design quality, including the design document, is 50%
									of your project grade.  It
									is better to spend one or two hours writing a good design document than
									it is to spend that time getting the last 5% of the points for tests and
									then trying to rush through writing the design document in the last 15
									minutes.
									</P>
									<div id="design" class="content">
									<h4>Design Document</h4>
										<P>
										We provide a design document template for each project.  For each
										significant part of a project, the template asks questions in four
										areas: 
										</P>
										<P>
										</P>
										<DL COMPACT>
										<DT><STRONG>Data Structures</STRONG>
										<DD><P>
										The instructions for this section are always the same:
										</P>
										<P>
										The first part is mechanical. Just copy new or modified declarations
										into the design document, to highlight for us the actual changes to data
										structures. Each declaration should include the comment that should
										accompany it in the source code (see below).
										</P>
										<P>
										We also ask for a very brief description of the purpose of each new or
										changed data structure. The limit of 25 words or less is a guideline
										intended to save your time and avoid duplication with later areas.
										</P>
										<P>
										</P>
										<DT><STRONG>Algorithms</STRONG>
										<DD><P>
										This is where you tell us how your code works, through questions that
										probe your understanding of your code.  We might not be able to easily
										figure it out from the code, because many creative solutions exist for
										most OS problems.  Help us out a little.
										</P>
										<P>
										Your answers should be at a level below the high level description of
										requirements given in the assignment.  We have read the assignment too,
										so it is unnecessary to repeat or rephrase what is stated there.  On the
										other hand, your answers should be at a level above the low level of the
										code itself.  Don't give a line-by-line run-down of what your code does.
										Instead, use your answers to explain how your code works to implement
										the requirements.
										</P>
										<P>

										</P>
										<DT><STRONG>Synchronization</STRONG>
										<DD><P>

										An operating system kernel is a complex, multithreaded program, in which
										synchronizing multiple threads can be difficult.  This section asks
										about how you chose to synchronize this particular type of activity.
										</P>
										<P>

										</P>
										<DT><STRONG>Rationale</STRONG>
										<DD><P>

										Whereas the other sections primarily ask &quot;what&quot; and &quot;how,&quot; the
										rationale section concentrates on &quot;why.&quot;  This is where we ask you to
										justify some design decisions, by explaining why the choices you made
										are better than alternatives.  You may be able to state these in terms
										of time and space complexity, which can be made as rough or informal
										arguments (formal language or proofs are unnecessary).
										</DL>
										<P>

										An incomplete, evasive, or non-responsive design document or one that
										strays from the template without good reason may be penalized.
										Incorrect capitalization, punctuation, spelling, or grammar can also
										cost points.  See section <A HREF="pintos_9.html#SEC142">D. Project Documentation</A>, for a sample design document
										for a fictitious project.
										</P>									
										</div> <!--//content-->
										<div id="source" class="content">
											<h4>Source Code</h4>
											<P>

                                                Your design will also be judged by looking at your source code.  We will
                                                typically look at the differences between the original Pintos source
                                                tree and your submission, based on the output of a command like
                                                <CODE>diff -urpb pintos.orig pintos.submitted</CODE>.  We will try to match up your
                                                description of the design with the code submitted.  Important
                                                discrepancies between the description and the actual code will be
                                                penalized, as will be any bugs we find by spot checks.
                                            </P>
                                            <P>

                                                The most important aspects of source code design are those that specifically
                                                relate to the operating system issues at stake in the project.  For
                                                example, the organization of an inode is an important part of file
                                                system design, so in the file system project a poorly designed inode
                                                would lose points.  Other issues are much less important.  For
                                                example, multiple Pintos design problems call for a &quot;priority
                                                queue,&quot; that is, a dynamic collection from which the minimum (or
                                                maximum) item can quickly be extracted.  Fast priority queues can be
                                                implemented many ways, but we do not expect you to build a fancy data
                                                structure even if it might improve performance.  Instead, you are
                                                welcome to use a linked list (and Pintos even provides one with
                                                convenient functions for sorting and finding minimums and maximums).
                                            </P>
                                            <P>

                                                Pintos is written in a consistent style.  Make your additions and
                                                modifications in existing Pintos source files blend in, not stick out.
                                                In new source files, adopt the existing Pintos style by preference, but
                                                make your code self-consistent at the very least.  There should not be a
                                                patchwork of different styles that makes it obvious that three different
                                                people wrote the code.  Use horizontal and vertical white space to make
                                                code readable.  Add a brief comment on every structure, structure
                                                member, global or static variable, typedef, enumeration, and function
                                                definition.  Update
                                                existing comments as you modify code.  Don't comment out or use the
                                                preprocessor to ignore blocks of code (instead, remove it entirely).
                                                Use assertions to document key invariants.  Decompose code into
                                                functions for clarity.  Code that is difficult to understand because it
                                                violates these or other &quot;common sense&quot; software engineering practices
                                                will be penalized.
                                            </P>
                                            <P>

                                                In the end, remember your audience.  Code is written primarily to be
                                                read by humans.  It has to be acceptable to the compiler too, but the
                                                compiler doesn't care about how it looks or how well it is written.
                                            </P>
										</div> <!-- content -->
                                </div><!--//section-block-->
                               
                            </section><!--//doc-section-->
                            
                            <section id="legal-section" class="doc-section">
                                <h2 class="section-title">Legal and Ethical Issues</h2>
                                <div class="section-block">
                                 <P>

                                    Pintos is distributed under a liberal license that allows free use,
                                    modification, and distribution.  Students and others who work on Pintos
                                    own the code that they write and may use it for any purpose.
                                    Pintos comes with NO WARRANTY, not even for MERCHANTABILITY or FITNESS
                                    FOR A PARTICULAR PURPOSE.
                                    See section <A HREF="pintos_14.html#SEC172">License</A>, for details of the license and lack of warranty.
                                </P>
                                <P>

                                    In the context of Stanford's CS 140 course, please respect the spirit
                                    and the letter of the honor code by refraining from reading any homework
                                    solutions available online or elsewhere.  Reading the source code for
                                    other operating system kernels, such as Linux or FreeBSD, is allowed,
                                    but do not copy code from them literally.  Please cite the code that
                                    inspired your own in your design documentation.
                                </P>
                            </section><!--//legal-section-->
                            <section id="ack-section" class="doc-section">
                                <h2 class="section-title">Acknowledgements</h2>
                                <div class="section-block">
                                 <P>
                                    The Pintos core and this documentation were originally written by Ben
                                    Pfaff <A HREF="mailto:blp@cs.stanford.edu">blp@cs.stanford.edu</A>.
                                </P>
                                <P>
                                    Additional features were contributed by Anthony Romano
                                    <A HREF="mailto:chz@vt.edu">chz@vt.edu</A>.
                                </P>
                                <P>
                                    The GDB macros supplied with Pintos were written by Godmar Back
                                    <A HREF="mailto:gback@cs.vt.edu">gback@cs.vt.edu</A>, and their documentation is adapted from his
                                    work.
                                </P>
                                <P>
                                    The original structure and form of Pintos was inspired by the Nachos
                                    instructional operating system from the University of California,
                                    Berkeley ([ <A HREF="pintos_13.html#Christopher">Christopher</A>]).
                                </P>
                                <P>
                                    The Pintos projects and documentation originated with those designed for
                                    Nachos by current and former CS 140 teaching assistants at Stanford
                                    University, including at least Yu Ping, Greg Hutchins, Kelly Shaw, Paul
                                    Twohey, Sameer Qureshi, and John Rector.
                                </P>
                                <P>
                                    Example code for monitors (see section <A HREF="pintos_6.html#SEC104">A.3.4 Monitors</A>) is
                                    from classroom slides originally by Dawson Engler and updated by Mendel
                                    Rosenblum.
                                </P>
                            </section><!--//legal-section-->
                            <section id="trivia-section" class="doc-section">
                                <h2 class="section-title">Trivia</h2>
                                <div class="section-block">
                                <P>
                                    Pintos originated as a replacement for Nachos with a similar design.
                                    Since then Pintos has greatly diverged from the Nachos design.  Pintos
                                    differs from Nachos in two important ways.  First, Pintos runs on real
                                    or simulated 80<VAR>x</VAR>86 hardware, but Nachos runs as a process on a
                                    host operating system.  Second, Pintos is written in C like most
                                    real-world operating systems, but Nachos is written in C++.
                                </P>
                                <P>

                                    Why the name &quot;Pintos&quot;?  First, like nachos, pinto beans are a common
                                    Mexican food.  Second, Pintos is small and a &quot;pint&quot; is a small amount.
                                    Third, like drivers of the eponymous car, students are likely to have
                                    trouble with blow-ups.
                                </P>
                            </section><!--//legal-section-->
                            
                            
                            </section><!--//doc-section-->
                        </div><!--//content-inner-->
                    </div><!--//doc-content-->
                    <div class="doc-sidebar hidden-xs">
                        <nav id="doc-nav">
                            <ul id="doc-menu" class="nav doc-menu" data-spy="affix">
                                <li><a class="scrollto" href="#start-section">Getting Started</a>
                                    <ul class="nav doc-sub-menu">
                                        <li><a class="scrollto" href="#sourcetree">Source Tree Overview</a></li>
                                        <li><a class="scrollto" href="#building">Building Pintos</a></li>
                                        <li><a class="scrollto" href="#running">Running Pintos</a></li>
                                        <li><a class="scrollto" href="#debugging">Debugging versus Testing</a></li>
                                    </ul><!--//nav-->
                                </li>
                                <li>
                                    <a class="scrollto" href="#grading-section">Grading</a>
                                    <ul class="nav doc-sub-menu">
                                        <li><a class="scrollto" href="#testing">Testing</a></li>
                                        <li><a class="scrollto" href="#design">Design</a></li>
                                    </ul><!--//nav-->
                                </li>
                                <li><a class="scrollto" href="#legal-section">Legal and Ethical Issues</a></li>
                                <li><a class="scrollto" href="#ack-section">Acknoledgements</a></li>
                                <li><a class="scrollto" href="#trivia-section">Trivia</a></li>
                            </ul><!--//doc-menu-->
                        </nav>
                    </div><!--//doc-sidebar-->
                </div><!--//doc-body-->              
            </div><!--//container-->
        </div><!--//doc-wrapper-->
        
     
        
    </div><!--//page-wrapper-->
    
    <footer id="footer" class="footer text-center">
        <div class="container">
            <small class="copyright"> 이 문서의 저작권은 이 프로젝트의 Github repository에 있는 license.md 파일에 따릅니다.</small>
                <br>
                <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can check out other license options via our website: themes.3rdwavemedia.com */-->
                <small class="copyright">The template is designed with <i class="fa fa-heart"></i> by <a href="http://themes.3rdwavemedia.com/" targe="_blank">Xiaoying Riley</a> for developers</small>
            
        </div><!--//container-->
    </footer><!--//footer-->
    
     
    <!-- Main Javascript -->          
    <script type="text/javascript" src="assets/plugins/jquery-1.12.3.min.js"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/plugins/prism/prism.js"></script>    
    <script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>                                                                
    <script type="text/javascript" src="assets/plugins/jquery-match-height/jquery.matchHeight-min.js"></script>
    <script type="text/javascript" src="assets/js/main.js"></script>
    
</body>
</html> 

