<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html40/loose.dtd">
<HTML>

<HEAD>
<TITLE>Pintos Projects: Introduction</TITLE>

<META NAME="description" CONTENT="Pintos Projects: Introduction">
<META NAME="keywords" CONTENT="Pintos Projects: Introduction Korean, 한국어 Pintos">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.66">
<LINK REL="stylesheet" HREF="pintos.css">
</HEAD>

<BODY >

<A NAME="SEC1"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Top"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_2.html#SEC15"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>

<HR SIZE=2>
<A NAME="Introduction"></A>
<H1> 1. Introduction </H1>
<!--docid::SEC1::-->
<P>
<b>Pintos</b>의 세계에 오신 것을 환영합니다. Pintos는 80x86 architecture의 CPU를 위한 간단한 Operating System 입니다. 이 OS는 커널 쓰레드, 사용자 프로그램 (어플리케이션), 파일 시스템을 지원하기 위해 아주 간략하게 구현되어 있습니다. 이 프로젝트를 통해 당신 (그리고 당신의 팀)은 앞서 언급된 세 가지 기능을 강화시켜야 합니다. 또한, Virtual Memory를 구현하게 될 것입니다.
</P>
<P>

이론적으로 Pintos는 보통의 IBM-호환(x86) PC에서 동작할 수 있습니다. 하지만 여러 이유로 Pintos를 각자의 PC에서 직접 돌려보는 것은 현실적으로 어렵습니다. 따라서, 우리는 system simulator 위에서 Pintos를 실행 시킬 것입니다. 이 프로그램들은 80x86 CPU와 주변 장치들을 시뮬레이트 할 수 있는 소프트웨어입니다. Pintos 프로젝트에서는 <A HREF="http://bochs.sourceforge.net">Bochs</A> 와
<A HREF="http://fabrice.bellard.free.fr/qemu/">QEMU</A> simulator를 사용합니다. 또한, <A HREF="http://www.vmware.com/">VMware Player</A>에서도 Pintos가 작동하는 것이 검증된 바 있습니다.
</P>
<P>

이 프로젝트들은 어렵습니다. 아시다시피, Pintos는 여러 대학교의 운영체제 과목의 난이도 높은 프로젝트로 유명합니다. 하지만 이 문서를 꼼꼼히 읽고 진행한다면, 아마 많은 시행착오를 줄이고, 어렵지 않게 프로젝트를 진행해 나갈 수 있을 것입니다. 자세히 보시면 상당히 많은 팁들이 숨어 있습니다. 

</P>
<P>
이 장은 Pintos를 다루기 시작하는 방법을 설명합니다. 가능하다면 먼저 이 장을 열심히 읽고 프로젝트를 시작하기를 권장합니다. 
</P>
<P>

<A NAME="Getting Started"></A>
<HR SIZE="6">
<A NAME="SEC2"></A>
<H2> 1.1 Getting Started </H2>
<!--docid::SEC2::-->
<P>

프로젝트를 시작하기 위해 Pintos를 build할 수 있는 system을 준비합니다. (리눅스 머신을 권장합니다) 
<A HREF="http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz">http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz</A> 의 소스코드를 받아 압축을 풀고, Pintos binary의 directory ([pintos_path]/src/utils/)를 <CODE>PATH</CODE> 환경변수에 추가해야 합니다.
</P>
<P>

<A NAME="Source Tree Overview"></A>
<HR SIZE="6">
<A NAME="SEC3"></A>
<H3> 1.1.1 Source Tree Overview </H3>
<!--docid::SEC3::-->
<P>
이제 Pintos에 어떤 것들이 들어있는지 살펴봅시다. 아래는 <Q><TT>pintos/src</TT></Q>에서 볼 수 있는 directory들입니다.
</P>
<P>

</P>
<DL COMPACT>
<DT><Q><TT>threads/</TT></Q>
<DD>Project 1부터 수정하게 될 Base kernel을 위한 source code들이 들어 있습니다. 
<P>

</P>
<DT><Q><TT>userprog/</TT></Q>
<DD>roject 2에서 고치게 될 User program loader의 source code들이 들어 있습니다. 
<P>

</P>
<DT><Q><TT>vm/</TT></Q>
<DD>Project 3에서 Virtual Memory를 implement할 곳입니다.
<P>

</P>
<DT><Q><TT>filesys/</TT></Q>
<DD>Basic File System의 source code들이 들어 있습니다. Project 2의 file 관련 system call을 위해 사용해야 하며, Project 4 이전에 수정할 필요는 없을 것입니다.
<P>

</P>
<DT><Q><TT>devices/</TT></Q>
<DD>I/O device (Keyboard, timer, disk, 등등) 인터페이스 관련 소스코드들이 들어있습니다. Project 1에서 timer를 고치게 될 것이며, 이외에 수정할 부분은 없을 것 입니다.
<P>

</P>
<DT><Q><TT>lib/</TT></Q>
<DD>Standard C library의 일부가 들어있습니다. 이 코드들은 pintos 커널, 사용자 프로그램과 함께 컴파일 됩니다. 이 라이브러리의 헤더파일들은 커널과 사용자 프로그램 모두에서 <CODE>#include &lt;<small>...</small>&gt;</CODE> 형태로 include하면 됩니다. 경우에 따라, 프로젝트를 진행하면서 이들 중 일부를 조금 고쳐야할 수도 있습니다. 
<P>

</P>
<DT><Q><TT>lib/kernel/</TT></Q>
<DD>Pintos kernel만 사용하는 C library가 들어있는 디렉토리입니다. kernel code에서 사용할 수 있는 data type들 (비트맵, 더블 링크드 리스트, 해시 테이블 등)이 포함되어 있습니다. Kernel 코드에서는 이 라이브러리의 헤더 파일들을 다음과 같은 형태로 include 할 수 있습니다. <CODE>#include &lt;<small>...</small>&gt;</CODE>
<P>

</P>
<DT><Q><TT>lib/user/</TT></Q>
<DD>Pintos의 사용자 프로그램에서만 사용되는 C Library가 들어있는 디렉토리입니다. 위와 같이, 사용자 프로그램에선 <CODE>#include &lt;<small>...</small>&gt;</CODE>의 형태로 헤더 파일들을 include할 수 있습니다.
<P>

</P>
<DT><Q><TT>tests/</TT></Q>
<DD>각 프로젝트들의 test들이 들어있는 디렉토리입니다. 더 많은 testing을 위해 수정하거나 추가할 수 있지만, 보통 채점은 original test들로 이루어 집니다.
<P>

</P>
<DT><Q><TT>examples/</TT></Q>
<DD>예제 사용자 프로그램들이 들어있는 디렉토리입니다.
<P>

</P>
<DT><Q><TT>misc/</TT></Q>
<DD><DT><Q><TT>utils/</TT></Q>
<DD>Pintos를 세팅할 때 쓰일 수 있는 잡동사니들이 들어 있습니다. 
</DL>
<P>

<A NAME="Building Pintos"></A>
<HR SIZE="6">
<A NAME="SEC4"></A>
<H3> 1.1.2 Building Pintos </H3>
<!--docid::SEC4::-->
<P>

다음 단계로, 프로젝트 1을 위한 소스 코드를 빌드 해 봅시다.
먼저, <Q><TT>threads</TT></Q> 디렉토리로 들어가서 <Q><SAMP>make</SAMP></Q> 명령어를 실행 해 봅니다. Make 스크립트가 빌드를 마치면 <Q><TT>build</TT></Q>라는 디렉토리가 생성 될 것입니다. 이 안에는 빌드가 완료된 현재 버전의 Pintos 커널이 들어있게 됩니다. 전체 빌드 과정은 보통 30초 이내 입니다. (5분 이상 걸린다면 보통 심각한 문제가 있다고 보면 됩니다.)
</P>
<P>

Build를 진행하면서 사용되는 명령어들을 보시면, 특별할 것 없이 리눅스에서 흔히 사용되는 시스템 도구들이 불려집니다.
</P>
<P>



<Q><TT>build</TT></Q> 디렉토리에서 중요한 파일들은 다음과 같습니다.
</P>
<P>

</P>
<DL COMPACT>
<DT><Q><TT>Makefile</TT></Q>
<DD><Q><TT>pintos/src/Makefile.build</TT></Q>의 복사본입니다.  이 파일은 커널을 build하는 방법에 대한 정보를 가지고 있습니다. 자세한 내용은 <A HREF="pintos_2.html#Adding Source Files">"Adding Source Files"</A> 를 참조하시기 바랍니다..
<P>

</P>
<DT><Q><TT>kernel.o</TT></Q>
<DD>전체 커널의 Object 파일입니다. 즉, 모든 개별 커널 소스 파일들을 Link해 놓은 결과물입니다. 이 파일은 디버그 정보를 가지고 있기 때문에, GDB (see section <A HREF="pintos_10.html#SEC151">E.5 GDB</A>) 나 <CODE>backtrace</CODE> (see section <A HREF="pintos_10.html#SEC149">E.4 Backtraces</A>)를 적용하여 디버깅을 할 수 있습니다. 
<P>

</P>
<DT><Q><TT>kernel.bin</TT></Q>
<DD>커널의 메모리 이미지, 즉 pintos 커널을 실행시키기 위해 Load되는 메모리입니다. 사실상 이것은 디버그 관련 정보가 제거된 kernel.o 파일인데, 커널 로더의 디자인이 커널 사이즈 크기를 512KB로 제한하기 때문에 사용하는 파읿입니다.
<P>

</P>
<DT><Q><TT>loader.bin</TT></Q>
<DD>커널 로더의 메모리 이미지입니다. 커널 로더는 디스크로부터 커널을 읽고, 메모리에 이를 올려주는 역할을 합니다. 이 파일의 사이즈는 PC BIOS의 요구사항 때문에 정확히 512바이트여야 합니다.
</DL>
<P>


<Q><TT>build</TT></Q>의 서브 디렉토리들은 컴파일러가 생성한 object 파일 (<Q><TT>.o</TT></Q>)와 
dependency 파일 (<Q><TT>.d</TT></Q>)들을 포함합니다. 
dependency 파일들은 <CODE>make</CODE> 스크립트에 다른 소스나 헤더파일이 변경되었을 때, 어떤 파일들이 재컴파일 되어야 하는지를 알려줍니다.
</P>
<P>

<A NAME="Running Pintos"></A>
<HR SIZE="6">
<A NAME="SEC5"></A>
<H3> 1.1.3 Running Pintos </H3>
<!--docid::SEC5::-->
<P>
우리는 Pintos를 simulator에서 쉽게 구동시킬 수 있는 프로그램인 <CODE>pintos</CODE>를 제공합니다. 여러분은 간단히, <CODE>pintos</CODE>를 <CODE>pintos <VAR>argument</VAR><small>...</small></CODE> 형태로 실행시킬 수 있습니다. 각각의 <VAR>argument</VAR>는 여러분이 수정하는 Pintos 커널로 전달 됩니다.
</P>
<P>

Try it out.  First <CODE>cd</CODE> into the newly created <Q><TT>build</TT></Q>
directory.  Then issue the command <CODE>pintos run alarm-multiple</CODE>,
which passes the arguments <CODE>run alarm-multiple</CODE> to the Pintos
kernel.  In these arguments, <CODE>run</CODE> instructs the kernel to run a
test and <CODE>alarm-multiple</CODE> is the test to run.
</P>
<P>

This command creates a <Q><TT>bochsrc.txt</TT></Q> file, which is needed for
running Bochs, and then invoke Bochs.  Bochs opens a new window that
represents the simulated machine's display, and a BIOS message briefly
flashes.  Then Pintos boots and runs the <CODE>alarm-multiple</CODE> test
program, which outputs a few screenfuls of text.  When it's done, you
can close Bochs by clicking on the &quot;Power&quot; button in the window's top
right corner, or rerun the whole process by clicking on the &quot;Reset&quot;
button just to its left.  The other buttons are not very useful for our
purposes.
</P>
<P>

(If no window appeared at all, then you're probably logged in remotely and X
forwarding is not set up correctly.  In this case, you can fix your X
setup, or you can use the <Q><SAMP>-v</SAMP></Q> option to disable X output:
<CODE>pintos -v -- run alarm-multiple</CODE>.)
</P>
<P>

The text printed by Pintos inside Bochs probably went by too quickly to
read.  However, you've probably noticed by now that the same text was
displayed in the terminal you used to run <CODE>pintos</CODE>.  This is
because Pintos sends all output both to the VGA display and to the first
serial port, and by default the serial port is connected to Bochs's
<CODE>stdin</CODE> and <CODE>stdout</CODE>.  You can log serial output to a file by
redirecting at the
command line, e.g. <CODE>pintos run alarm-multiple &gt; logfile</CODE>.
</P>
<P>

The <CODE>pintos</CODE> program offers several options for configuring the
simulator or the virtual hardware.  If you specify any options, they
must precede the commands passed to the Pintos kernel and be separated
from them by <Q><SAMP>--</SAMP></Q>, so that the whole command looks like
<CODE>pintos <VAR>option</VAR><small>...</small> -- <VAR>argument</VAR><small>...</small></CODE>.  Invoke
<CODE>pintos</CODE> without any arguments to see a list of available options.
Options can select a simulator to use: the default is Bochs, but
<Q><SAMP>--qemu</SAMP></Q> selects QEMU.  You can run the simulator
with a debugger (see section <A HREF="pintos_10.html#SEC151">E.5 GDB</A>).  You can set the amount of memory to give
the VM.  Finally, you can select how you want VM output to be displayed:
use <Q><SAMP>-v</SAMP></Q> to turn off the VGA display, <Q><SAMP>-t</SAMP></Q> to use your
terminal window as the VGA display instead of opening a new window
(Bochs only), or <Q><SAMP>-s</SAMP></Q> to suppress serial input from <CODE>stdin</CODE>
and output to <CODE>stdout</CODE>.
</P>
<P>

The Pintos kernel has commands and options other than <CODE>run</CODE>.
These are not very interesting for now, but you can see a list of them
using <Q><SAMP>-h</SAMP></Q>, e.g. <CODE>pintos -h</CODE>.
</P>
<P>

<A NAME="Debugging versus Testing"></A>
<HR SIZE="6">
<A NAME="SEC6"></A>
<H3> 1.1.4 Debugging versus Testing </H3>
<!--docid::SEC6::-->
<P>

When you're debugging code, it's useful to be able to run a
program twice and have it do exactly the same thing.  On second and
later runs, you can make new observations without having to discard or
verify your old observations.  This property is called
&quot;reproducibility.&quot;  One of the simulators that Pintos supports, Bochs,
can be set up for
reproducibility, and that's the way that <CODE>pintos</CODE> invokes it
by default.
</P>
<P>

Of course, a simulation can only be reproducible from one run to the
next if its input is the same each time.  For simulating an entire
computer, as we do, this means that every part of the computer must be
the same.  For example, you must use the same command-line argument, the
same disks, the same version
of Bochs, and you must not hit any keys on the keyboard (because you
could not be sure to hit them at exactly the same point each time)
during the runs.
</P>
<P>

While reproducibility is useful for debugging, it is a problem for
testing thread synchronization, an important part of most of the projects.  In
particular, when Bochs is set up for reproducibility, timer interrupts
will come at perfectly reproducible points, and therefore so will
thread switches.  That means that running the same test several times
doesn't give you any greater confidence in your code's correctness
than does running it only once.
</P>
<P>

So, to make your code easier to test, we've added a feature, called
&quot;jitter,&quot; to Bochs, that makes timer interrupts come at random
intervals, but in a perfectly predictable way.  In particular, if you
invoke <CODE>pintos</CODE> with the option <Q><SAMP>-j <VAR>seed</VAR></SAMP></Q>, timer
interrupts will come at irregularly spaced intervals.  Within a single
<VAR>seed</VAR> value, execution will still be reproducible, but timer
behavior will change as <VAR>seed</VAR> is varied.  Thus, for the highest
degree of confidence you should test your code with many seed values.
</P>
<P>

On the other hand, when Bochs runs in reproducible mode, timings are not
realistic, meaning that a &quot;one-second&quot; delay may be much shorter or
even much longer than one second.  You can invoke <CODE>pintos</CODE> with
a different option, <Q><SAMP>-r</SAMP></Q>, to set up Bochs for realistic
timings, in which a one-second delay should take approximately one
second of real time.  Simulation in real-time mode is not reproducible,
and options <Q><SAMP>-j</SAMP></Q> and <Q><SAMP>-r</SAMP></Q> are mutually exclusive.
</P>
<P>

The QEMU simulator is available as an
alternative to Bochs (use <Q><SAMP>--qemu</SAMP></Q> when invoking
<CODE>pintos</CODE>).  The QEMU simulator is much faster than Bochs, but it
only supports real-time simulation and does not have a reproducible
mode.
</P>
<P>

<A NAME="Grading"></A>
<HR SIZE="6">
<A NAME="SEC7"></A>
<H2> 1.2 Grading </H2>
<!--docid::SEC7::-->
<P>

We will grade your assignments based on test results and design quality,
each of which comprises 50% of your grade.
</P>
<P>

<A NAME="Testing"></A>
<HR SIZE="6">
<A NAME="SEC8"></A>
<H3> 1.2.1 Testing </H3>
<!--docid::SEC8::-->
<P>

Your test result grade will be based on our tests.  Each project has
several tests, each of which has a name beginning with <Q><TT>tests</TT></Q>.
To completely test your submission, invoke <CODE>make check</CODE> from the
project <Q><TT>build</TT></Q> directory.  This will build and run each test and
print a &quot;pass&quot; or &quot;fail&quot; message for each one.  When a test fails,
<CODE>make check</CODE> also prints some details of the reason for failure.
After running all the tests, <CODE>make check</CODE> also prints a summary
of the test results.
</P>
<P>

For project 1, the tests will probably run faster in Bochs.  For the
rest of the projects, they will run much faster in QEMU.
<CODE>make check</CODE> will select the faster simulator by default, but
you can override its choice by specifying <Q><SAMP>SIMULATOR=--bochs</SAMP></Q> or
<Q><SAMP>SIMULATOR=--qemu</SAMP></Q> on the <CODE>make</CODE> command line.
</P>
<P>

You can also run individual tests one at a time.  A given test <VAR>t</VAR>
writes its output to <Q><TT><VAR>t</VAR>.output</TT></Q>, then a script scores the
output as &quot;pass&quot; or &quot;fail&quot; and writes the verdict to
<Q><TT><VAR>t</VAR>.result</TT></Q>.  To run and grade a single test, <CODE>make</CODE>
the <Q><TT>.result</TT></Q> file explicitly from the <Q><TT>build</TT></Q> directory, e.g.
<CODE>make tests/threads/alarm-multiple.result</CODE>.  If <CODE>make</CODE> says
that the test result is up-to-date, but you want to re-run it anyway,
either run <CODE>make clean</CODE> or delete the <Q><TT>.output</TT></Q> file by hand.
</P>
<P>

By default, each test provides feedback only at completion, not during
its run.  If you prefer, you can observe the progress of each test by
specifying <Q><SAMP>VERBOSE=1</SAMP></Q> on the <CODE>make</CODE> command line, as in
<CODE>make check VERBOSE=1</CODE>.  You can also provide arbitrary options to the
<CODE>pintos</CODE> run by the tests with <Q><SAMP>PINTOSOPTS='<small>...</small>'</SAMP></Q>,
e.g. <CODE>make check PINTOSOPTS='-j 1'</CODE> to select a jitter value of 1
(see section <A HREF="pintos_1.html#SEC6">1.1.4 Debugging versus Testing</A>).
</P>
<P>

All of the tests and related files are in <Q><TT>pintos/src/tests</TT></Q>.
Before we test your submission, we will replace the contents of that
directory by a pristine, unmodified copy, to ensure that the correct
tests are used.  Thus, you can modify some of the tests if that helps in
debugging, but we will run the originals.
</P>
<P>

All software has bugs, so some of our tests may be flawed.  If you think
a test failure is a bug in the test, not a bug in your code,
please point it out.  We will look at it and fix it if necessary.
</P>
<P>

Please don't try to take advantage of our generosity in giving out our
test suite.  Your code has to work properly in the general case, not
just for the test cases we supply.  For example, it would be unacceptable
to explicitly base the kernel's behavior on the name of the running
test case.  Such attempts to side-step the test cases will receive no
credit.  If you think your solution may be in a gray area here, please
ask us about it.
</P>
<P>

<A NAME="Design"></A>
<HR SIZE="6">
<A NAME="SEC9"></A>
<H3> 1.2.2 Design </H3>
<!--docid::SEC9::-->
<P>

We will judge your design based on the design document and the source
code that you submit.  We will read your entire design document and much
of your source code.  
</P>
<P>

Don't forget that design quality, including the design document, is 50%
of your project grade.  It
is better to spend one or two hours writing a good design document than
it is to spend that time getting the last 5% of the points for tests and
then trying to rush through writing the design document in the last 15
minutes.
</P>
<P>

<A NAME="Design Document"></A>
<HR SIZE="6">
<A NAME="SEC10"></A>
<H4> 1.2.2.1 Design Document </H4>
<!--docid::SEC10::-->
<P>

We provide a design document template for each project.  For each
significant part of a project, the template asks questions in four
areas: 
</P>
<P>

</P>
<DL COMPACT>
<DT><STRONG>Data Structures</STRONG>
<DD><P>

The instructions for this section are always the same:
</P>
<P>

<BLOCKQUOTE>
Copy here the declaration of each new or changed <CODE>struct</CODE> or
<CODE>struct</CODE> member, global or static variable, <CODE>typedef</CODE>, or
enumeration.  Identify the purpose of each in 25 words or less.
</BLOCKQUOTE>
<P>

The first part is mechanical.  Just copy new or modified declarations
into the design document, to highlight for us the actual changes to data
structures.  Each declaration should include the comment that should
accompany it in the source code (see below).
</P>
<P>

We also ask for a very brief description of the purpose of each new or
changed data structure.  The limit of 25 words or less is a guideline
intended to save your time and avoid duplication with later areas.
</P>
<P>

</P>
<DT><STRONG>Algorithms</STRONG>
<DD><P>

This is where you tell us how your code works, through questions that
probe your understanding of your code.  We might not be able to easily
figure it out from the code, because many creative solutions exist for
most OS problems.  Help us out a little.
</P>
<P>

Your answers should be at a level below the high level description of
requirements given in the assignment.  We have read the assignment too,
so it is unnecessary to repeat or rephrase what is stated there.  On the
other hand, your answers should be at a level above the low level of the
code itself.  Don't give a line-by-line run-down of what your code does.
Instead, use your answers to explain how your code works to implement
the requirements.
</P>
<P>

</P>
<DT><STRONG>Synchronization</STRONG>
<DD><P>

An operating system kernel is a complex, multithreaded program, in which
synchronizing multiple threads can be difficult.  This section asks
about how you chose to synchronize this particular type of activity.
</P>
<P>

</P>
<DT><STRONG>Rationale</STRONG>
<DD><P>

Whereas the other sections primarily ask &quot;what&quot; and &quot;how,&quot; the
rationale section concentrates on &quot;why.&quot;  This is where we ask you to
justify some design decisions, by explaining why the choices you made
are better than alternatives.  You may be able to state these in terms
of time and space complexity, which can be made as rough or informal
arguments (formal language or proofs are unnecessary).
</DL>
<P>

An incomplete, evasive, or non-responsive design document or one that
strays from the template without good reason may be penalized.
Incorrect capitalization, punctuation, spelling, or grammar can also
cost points.  See section <A HREF="pintos_9.html#SEC142">D. Project Documentation</A>, for a sample design document
for a fictitious project.
</P>
<P>

<A NAME="Source Code"></A>
<HR SIZE="6">
<A NAME="SEC11"></A>
<H4> 1.2.2.2 Source Code </H4>
<!--docid::SEC11::-->
<P>

Your design will also be judged by looking at your source code.  We will
typically look at the differences between the original Pintos source
tree and your submission, based on the output of a command like
<CODE>diff -urpb pintos.orig pintos.submitted</CODE>.  We will try to match up your
description of the design with the code submitted.  Important
discrepancies between the description and the actual code will be
penalized, as will be any bugs we find by spot checks.
</P>
<P>

The most important aspects of source code design are those that specifically
relate to the operating system issues at stake in the project.  For
example, the organization of an inode is an important part of file
system design, so in the file system project a poorly designed inode
would lose points.  Other issues are much less important.  For
example, multiple Pintos design problems call for a &quot;priority
queue,&quot; that is, a dynamic collection from which the minimum (or
maximum) item can quickly be extracted.  Fast priority queues can be
implemented many ways, but we do not expect you to build a fancy data
structure even if it might improve performance.  Instead, you are
welcome to use a linked list (and Pintos even provides one with
convenient functions for sorting and finding minimums and maximums).
</P>
<P>

Pintos is written in a consistent style.  Make your additions and
modifications in existing Pintos source files blend in, not stick out.
In new source files, adopt the existing Pintos style by preference, but
make your code self-consistent at the very least.  There should not be a
patchwork of different styles that makes it obvious that three different
people wrote the code.  Use horizontal and vertical white space to make
code readable.  Add a brief comment on every structure, structure
member, global or static variable, typedef, enumeration, and function
definition.  Update
existing comments as you modify code.  Don't comment out or use the
preprocessor to ignore blocks of code (instead, remove it entirely).
Use assertions to document key invariants.  Decompose code into
functions for clarity.  Code that is difficult to understand because it
violates these or other &quot;common sense&quot; software engineering practices
will be penalized.
</P>
<P>

In the end, remember your audience.  Code is written primarily to be
read by humans.  It has to be acceptable to the compiler too, but the
compiler doesn't care about how it looks or how well it is written.
</P>
<P>

<A NAME="Legal and Ethical Issues"></A>
<HR SIZE="6">
<A NAME="SEC12"></A>
<H2> 1.3 Legal and Ethical Issues </H2>
<!--docid::SEC12::-->
<P>

Pintos is distributed under a liberal license that allows free use,
modification, and distribution.  Students and others who work on Pintos
own the code that they write and may use it for any purpose.
Pintos comes with NO WARRANTY, not even for MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.
See section <A HREF="pintos_14.html#SEC172">License</A>, for details of the license and lack of warranty.
</P>
<P>

In the context of Stanford's CS 140 course, please respect the spirit
and the letter of the honor code by refraining from reading any homework
solutions available online or elsewhere.  Reading the source code for
other operating system kernels, such as Linux or FreeBSD, is allowed,
but do not copy code from them literally.  Please cite the code that
inspired your own in your design documentation.
</P>
<P>

<A NAME="Acknowledgements"></A>
<HR SIZE="6">
<A NAME="SEC13"></A>
<H2> 1.4 Acknowledgements </H2>
<!--docid::SEC13::-->
<P>

The Pintos core and this documentation were originally written by Ben
Pfaff <A HREF="mailto:blp@cs.stanford.edu">blp@cs.stanford.edu</A>.
</P>
<P>

Additional features were contributed by Anthony Romano
<A HREF="mailto:chz@vt.edu">chz@vt.edu</A>.
</P>
<P>

The GDB macros supplied with Pintos were written by Godmar Back
<A HREF="mailto:gback@cs.vt.edu">gback@cs.vt.edu</A>, and their documentation is adapted from his
work.
</P>
<P>

The original structure and form of Pintos was inspired by the Nachos
instructional operating system from the University of California,
Berkeley ([ <A HREF="pintos_13.html#Christopher">Christopher</A>]).
</P>
<P>

The Pintos projects and documentation originated with those designed for
Nachos by current and former CS 140 teaching assistants at Stanford
University, including at least Yu Ping, Greg Hutchins, Kelly Shaw, Paul
Twohey, Sameer Qureshi, and John Rector.
</P>
<P>

Example code for monitors (see section <A HREF="pintos_6.html#SEC104">A.3.4 Monitors</A>) is
from classroom slides originally by Dawson Engler and updated by Mendel
Rosenblum.
</P>
<P>

<A NAME="Trivia"></A>
<HR SIZE="6">
<A NAME="SEC14"></A>
<H2> 1.5 Trivia </H2>
<!--docid::SEC14::-->
<P>

Pintos originated as a replacement for Nachos with a similar design.
Since then Pintos has greatly diverged from the Nachos design.  Pintos
differs from Nachos in two important ways.  First, Pintos runs on real
or simulated 80<VAR>x</VAR>86 hardware, but Nachos runs as a process on a
host operating system.  Second, Pintos is written in C like most
real-world operating systems, but Nachos is written in C++.
</P>
<P>

Why the name &quot;Pintos&quot;?  First, like nachos, pinto beans are a common
Mexican food.  Second, Pintos is small and a &quot;pint&quot; is a small amount.
Third, like drivers of the eponymous car, students are likely to have
trouble with blow-ups.
<A NAME="Project 1--Threads"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_1.html#SEC1"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_2.html#SEC15"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="pintos_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>
<FONT SIZE="-1">
This document was generated
by on <I>December, 29 2009</I>
using <A HREF="http://texi2html.cvshome.org"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
